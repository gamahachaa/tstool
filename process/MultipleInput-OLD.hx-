package process;
import layout.UIInputTf;
import lime.math.Rectangle;

/**
 * ...
 * @author bb
 */

typedef ValidatedInputs = {
	var ereg:EReg;
	var input:Input;
}
typedef Input = {
	var width:Int;
	var prefix:String;
	var ?position:Direction;
} 
 
class MultipleInput 
{
	var parent:Process;
	var first: UIInputTf;
	public var inputs(get, null):Map<String, UIInputTf>;

	public function new(parent:Process, ins: Array<Input>) 
	{
		first = null;
		this.inputs = [];
		this.parent = parent;
		create(ins);
		
	}
	public function create(ins:Array<Input>):Void
	{
		var tmp:UIInputTf= null;
		for ( i in ins)
		{
			tmp = new UIInputTf(Std.int(i.width), i.prefix, i.position);
			if (first == null) {
				first = tmp;
				first.addToParent(this.parent);
			}
			else
				tmp.addToParent(this.parent, false);
			inputs.set(i.prefix, tmp);
		}
	}
	
	function get_inputs():Map<String, UIInputTf>
	{
		return inputs;
	}
	
	public function positionThis()
	{
		var paretenRect = new Rectangle(this.parent.question.x, this.parent.question.y, this.parent.question.width, this.parent.question.height);
		var tmp = first;
		//trace(paretenRect);
		tmp.positionMe(paretenRect, this.parent._padding);
		//trace(tmp.boundingRect);
		//trace(tmp._label);
		for ( i in inputs)
		{
			
			if (i != first) {
				
				i.positionMe( tmp.boundingRect, this.parent._padding);
				tmp = i;
				//trace(i.boundingRect);
				//trace(i._label);
			}
			
		}
		
	}
	public function setStyle()
	{
		for (i in inputs)
		{
			i.setStyle();
		}
		
	}
}